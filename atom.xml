<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Max Blog]]></title>
  <link href="http://blog.sheliw.com/atom.xml" rel="self"/>
  <link href="http://blog.sheliw.com/"/>
  <updated>2016-01-20T22:04:17+08:00</updated>
  <id>http://blog.sheliw.com/</id>
  <author>
    <name><![CDATA[一切从简]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[我要采更多的雏菊]]></title>
    <link href="http://blog.sheliw.com/blog/2016/01/20/wo-yao-cai-geng-duo-de-chu-ju/"/>
    <updated>2016-01-20T21:55:35+08:00</updated>
    <id>http://blog.sheliw.com/blog/2016/01/20/wo-yao-cai-geng-duo-de-chu-ju</id>
    <content type="html"><![CDATA[<h4>太喜欢这首诗了，所以把它摘抄到我的博客里。</h4>

<h4>《我会采更多的雏菊》</h4>

<p>——美国诗人纳丁斯特尔在87岁写的</p>

<p>如果我能够从头活过，
我会试着犯更多的错。</p>

<p><br />我会放松一点，我会灵活一点。</p>

<p>我会比这一趟过得傻。</p>

<p>很少有什么事情能让我当真。</p>

<p><br />我会疯狂一些，我会少讲点卫生。</p>

<p>我会冒更多的险。我会更经常的旅行。</p>

<p>我会爬更多的山，游更多的河，看更多的日落。</p>

<p>我会多吃冰激凌，少吃豆子。</p>

<p>我会惹更多的麻烦，可是不在想象中担忧。</p>

<p><br />你看，我小心翼翼地稳健地理智地活着。</p>

<p>一个又一个小时，一天又一天。</p>

<p><br />噢，我有过难忘的时刻。</p>

<p>如果我能够重来一次，我会要更多这样的时刻。</p>

<p><br />事实上，我不需要别的什么，</p>

<p>仅仅是时刻，一个接着一个。</p>

<p>而不是每天都操心着以后的漫长日子。</p>

<p><br />我曾经不论到哪里都不忘记带上：</p>

<p>温度计，热水壶，雨衣和降落伞。</p>

<p><br />如果我能够重来一次，</p>

<p>我会到处走走，什么都试试，并且轻装上阵。</p>

<p>如果我能够重头活过，</p>

<p>我会延长打赤脚的时光。</p>

<p>从尽早的春天到尽晚的秋天。</p>

<p><br />我会更经常的逃学。</p>

<p>我不会考那么高的分数，除非是一不小心。</p>

<p>我会多骑些旋转木马，</p>

<p>我会采更多的雏菊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Python库ElementTree解析XML文件]]></title>
    <link href="http://blog.sheliw.com/blog/2015/09/05/shi-yong-pythonku-elementtreejie-xi-xmlwen-jian/"/>
    <updated>2015-09-05T19:18:30+08:00</updated>
    <id>http://blog.sheliw.com/blog/2015/09/05/shi-yong-pythonku-elementtreejie-xi-xmlwen-jian</id>
    <content type="html"><![CDATA[<p>最近打算做一个比较两个XML文件的小工具，然后就找到了Python的ElementTree，这个库非常高效，API也非常简洁。Python也有很多其他库可以用来解析XML文件。具体的对比请看这篇文章。</p>

<p><a href="http://pycoders-weekly-chinese.readthedocs.org/en/latest/issue6/processing-xml-in-python-with-element-tree.html">http://pycoders-weekly-chinese.readthedocs.org/en/latest/issue6/processing-xml-in-python-with-element-tree.html</a></p>

<p>上面这篇文章也介绍了一些使用ElementTree基本的方法。但是我在实际使用过程中遇到了很多其他的问题，比如没法处理XML文件内的注释，转义符等。最后对这些问题我也找到了一些解决办法。</p>

<h3>注释</h3>

<pre><code>&lt;Text&gt;
&lt;!-- 注释 --&gt;
&lt;/Text&gt;
</code></pre>

<p>我做的工具是先读取一个XML文件，然后和另一个XML文件做比较，再做一些修改，最后再写回原文件中。但是ElementTree默认会把XML文件的注释给忽略了，也就是XML文件写回去时之前的注释全不见了。最后发现重写xml.etree.cElementTree.XMLTreeBuilder内部的_parser.CommentHandler方法就可以解决这个问题。</p>

<pre><code>
import xml.etree.cElementTree as ET

class CommentedTreeBuilder(ET.XMLTreeBuilder):
    def __init__(self):
        ET.XMLTreeBuilder.__init__(self)
        # assumes ElementTree 1.2.X
        self._parser.CommentHandler = self.handle_comment

    def handle_comment(self, data):
        self._target.start(ET.Comment, {})
        self._target.data(data)
        self._target.end(ET.Comment)
        
 with open('test.xml', 'r') as f:
        tree = ET.parse(f, parser=CommentedTreeBuilder())

</pre>


<p></code>
但是这样解析XML文件之后，每一行的注释就会被当成一个普通的Element元素了，如果我们把它当作普通的元素去和其他元素比较，修改的时候就很容易出现问题。不过要判断这种注释元素也很简单，因为这种注释元素的tag类型并不是string类型。</p>

<pre><code>root = tree.getroot()
for item in root:
    iscomment = (type(item.tag) != type('str'))
</code></pre>

<h3>转义符</h3>

<p>用ElementTree的write()方法默认会对以下几种字符做转义，也就是字符串写入XML文件时遇到这三个字符都会被替换。</p>

<pre><code>
     if "&" in text:
         text = text.replace("&", "&amp;")
     if "<" in text:
         text = text.replace("<", "&lt;")
     if ">" in text:
         text = text.replace(">", "&gt;")
</pre>


<p></code>
这样虽然能保证生成的XML文件格式不出错。但是如果我还想让生成的XML文件内对空格，双引号，单引号做转义的话就比较难了。就算我在使用write()方法生成XML文件前用 xml.sax.saxutils.escape()方法手动转义，write()方法也会把所有&amp;字符给替换了。因为空格，双引号，单引号被转义后都是有&amp;字符的。</p>

<p>最后没有想到其他好办法，只好把ElementTree库拷贝了一份出来，然后对内部的_escape_cdata方法做了一些修改，然后就大功告成了。如果你有好的办法，欢迎给我留言。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[再见了，北京]]></title>
    <link href="http://blog.sheliw.com/blog/2015/07/12/dai-bu-zou-de-shi-qing-chun/"/>
    <updated>2015-07-12T21:03:01+08:00</updated>
    <id>http://blog.sheliw.com/blog/2015/07/12/dai-bu-zou-de-shi-qing-chun</id>
    <content type="html"><![CDATA[<p>明天毕业典礼，后天离开北京。今天校园里拍毕业照的人异常的多，看着总觉得很伤感。等这一刻其实也等了很久。</p>

<p>四年的喜怒哀乐马上要结束了。下次来北京也不知道会是什么时候，来北京还会不会想起曾经让我无限失落的往事。</p>

<p>2015年7月 北京</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keychain]]></title>
    <link href="http://blog.sheliw.com/blog/2015/02/16/keychain/"/>
    <updated>2015-02-16T15:27:43+08:00</updated>
    <id>http://blog.sheliw.com/blog/2015/02/16/keychain</id>
    <content type="html"><![CDATA[<h2>什么是Keychain?</h2>

<p>根据苹果的介绍，iOS设备中的Keychain是一个安全的存储容器，可以用来为不同应用保存敏感信息比如用户名，密码，网络密码，认证令牌。苹果自己用keychain来保存Wi-Fi网络密码，VPN凭证等等。它是一个在所有app之外的sqlite数据库。</p>

<p>如果我们手动把自己的私密信息加密，然后通过写文件保存在本地，再从本地取出不仅麻烦，而且私密信息也会随着App的删除而丢失。iOS的Keychain能完美的解决这些问题。并且从iOS 3.0开始，Keychain还支持跨程序分享。这样就极大的方便了用户。省去了很多要记忆密码的烦恼。</p>

<h2>Structure of a Keychain</h2>

<p>Keychain内部可以保存很多的信息。每条信息作为一个单独的keychain item，keychain item一般为一个字典，每条keychain item包含一条data和很多attributes。举个例子，一个用户账户就是一条item，用户名可以作为一个attribute , 密码就是data。 keychain虽然是可以保存15000条item,每条50个attributes，但是苹果工程师建议最好别放那么多，存几千条密码，几千字节没什么问题。</p>

<p>如果把keychain item的类型指定为需要保护的类型比如password或者private key，item的data会被加密并且保护起来，如果把类型指定为不需要保护的类型，比如certificates，item的data就不会被加密。</p>

<p>item可以指定为以下几种类型：</p>

<ul>
<li>extern CFTypeRef kSecClassGenericPassword</li>
<li>extern CFTypeRef kSecClassInternetPassword</li>
<li>extern CFTypeRef kSecClassCertificate</li>
<li>extern CFTypeRef kSecClassKey</li>
<li>extern CFTypeRef kSecClassIdentity
   <strong>OSX_AVAILABLE_STARTING(</strong>MAC_10_7, __IPHONE_2_0);</li>
</ul>


<h2>Keychain的用法</h2>

<p>首先导入Security.framework 。</p>

<p>Keychain的API提供以下几个函数来操作Keychain</p>

<ul>
<li>SecItemAdd 添加一个keychain item</li>
<li>SecItemUpdate 修改一个keychain item</li>
<li>SecItemCopyMatching 搜索一个keychain item</li>
<li>SecItemDelete 删除一个keychain item</li>
</ul>


<p>也可以参考以下这段简单的代码来了解下Keychain API的用法。</p>

<pre><code>
- (NSMutableDictionary *)newSearchDictionary:(NSString *)identifier {
    NSMutableDictionary *searchDictionary = [[NSMutableDictionary alloc] init];
    //指定item的类型为GenericPassword
    [searchDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];
    
    //类型为GenericPassword的信息必须提供以下两条属性作为unique identifier
    [searchDictionary setObject:encodedIdentifier forKey:(id)kSecAttrAccount]；
    [searchDictionary setObject:encodedIdentifier forKey:(id)kSecAttrService]；
    
    return searchDictionary;
}
- (NSData *)searchKeychainCopyMatching:(NSString *)identifier {
    NSMutableDictionary *searchDictionary = [self newSearchDictionary:identifier];
    
    //在搜索keychain item的时候必须提供下面的两条用于搜索的属性
    //只返回搜索到的第一条item
    [searchDictionary setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];
    //返回item的kSecValueData
    [searchDictionary setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData];
    
    NSData *result = nil;
    OSStatus status = SecItemCopyMatching((CFDictionaryRef)searchDictionary,
                                          (CFTypeRef *)&result);
    [searchDictionary release];
    return result;
}
- (BOOL)createKeychainValue:(NSString *)password forIdentifier:(NSString *)identifier {
    NSMutableDictionary *dictionary = [self newSearchDictionary:identifier];
    
    NSData *passwordData = [password dataUsingEncoding:NSUTF8StringEncoding];
    [dictionary setObject:passwordData forKey:(id)kSecValueData];
    
    OSStatus status = SecItemAdd((CFDictionaryRef)dictionary, NULL);
    [dictionary release];
    if (status == errSecSuccess) {
        return YES;
    }
    return NO;
}
- (BOOL)updateKeychainValue:(NSString *)password forIdentifier:(NSString *)identifier {
    NSMutableDictionary *searchDictionary = [self newSearchDictionary:identifier];
    
    NSMutableDictionary *updateDictionary = [[NSMutableDictionary alloc] init];
    NSData *passwordData = [password dataUsingEncoding:NSUTF8StringEncoding];
    [updateDictionary setObject:passwordData forKey:(id)kSecValueData];
    
    OSStatus status = SecItemUpdate((CFDictionaryRef)searchDictionary,
                                    (CFDictionaryRef)updateDictionary);
    
    [searchDictionary release];
    [updateDictionary release];
    
    if (status == errSecSuccess) {
        return YES;
    }
    return NO;
}
- (void)deleteKeychainValue:(NSString *)identifier {
    NSMutableDictionary *searchDictionary = [self newSearchDictionary:identifier];
    SecItemDelete((CFDictionaryRef)searchDictionary);
    [searchDictionary release];
}
</code></pre>


<p>Keychain API的用法稍微有点复杂。不过Apple自己也提供了一个封装了Keychain API的类：
KeychainItemWrapper
<a href="https://developer.apple.com/library/ios/samplecode/GenericKeychain/Introduction/Intro.html">https://developer.apple.com/library/ios/samplecode/GenericKeychain/Introduction/Intro.html</a>
虽然这个类封装了Keychain的API，但是不仅代码写的很不容易理解，而且里面也有不少的Bug。所以还是不建议使用。
目前发现这个类的1.2版存在的Bug为：</p>

<ol>
<li>如果需要某个keychain item支持iCloud备份，添加kSecAttrSynchronizable属性之后，它并没有在第二次更新item或者搜索item的时候加上这一条，所以导致item已经存在但是它却获取不到。</li>
<li>类型为GenericPassword的item必须使用kSecAttrAccount和kSecAttrService作为主要的key，但是这个类仅仅以kSecAttrGeneric作主要的key。所以在用它添加item的时候容易出现重复添加的错误。</li>
</ol>


<p>每种类型的Keychain item都有不同的键作为主要的Key也就是唯一标示符用于搜索，更新和删除，Keychain内部不允许添加重复的Item。</p>

<table>
<thead>
<tr>
<th>keychain item的类型，也就是kSecClass键的值        </th>
<th> 主要的Key</th>
</tr>
</thead>
<tbody>
<tr>
<td>kSecClassGenericPassword </td>
<td> kSecAttrAccount,kSecAttrService</td>
</tr>
<tr>
<td>kSecClassInternetPassword   </td>
<td> kSecAttrAccount, kSecAttrSecurityDomain, kSecAttrServer, kSecAttrProtocol,kSecAttrAuthenticationType, kSecAttrPortkSecAttrPath</td>
</tr>
<tr>
<td>kSecClassCertificate  </td>
<td> kSecAttrCertificateType, kSecAttrIssuerkSecAttrSerialNumber</td>
</tr>
<tr>
<td>kSecClassKey    </td>
<td> kSecAttrApplicationLabel, kSecAttrApplicationTag, kSecAttrKeyType,kSecAttrKeySizeInBits, kSecAttrEffectiveKeySize</td>
</tr>
<tr>
<td>kSecClassIdentity   </td>
<td> kSecClassKey,kSecClassCertificate</td>
</tr>
</tbody>
</table>


<h2>Keychain的备份</h2>

<ol>
<li><p>iOS的Keychain由系统管理并且进行加密，Keychain内的信息会随着iPhone的数据一起备份。但是kSecAttrAccessible 属性被设置为后缀是ThisDeviceOnly的数据会被以硬件相关的密钥(key)加密。并且不会随着备份移动至其他设备。</p>

<p>kSecAttrAccessiblein变量用来指定这条信息的保护程度。我们需要对这个选项特别注意，并且使用最严格的选项。这个键（key）可以设置6种值。</p>

<ul>
<li>CFTypeRef kSecAttrAccessibleWhenUnlocked;</li>
<li>CFTypeRef kSecAttrAccessibleAfterFirstUnlock;</li>
<li>CFTypeRef kSecAttrAccessibleAlways;</li>
<li>CFTypeRef kSecAttrAccessibleWhenUnlockedThisDeviceOnly;</li>
<li>CFTypeRef kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;</li>
<li>CFTypeRef kSecAttrAccessibleAlwaysThisDeviceOnly;</li>
</ul>


<p>从iOS5.0开始kSecAttrAccessible默认为kSecAttrAccessibleWhenUnlocked。</p></li>
<li><p>Keychain从iOS7.0开始也支持iCloud备份。把kSecAttrSynchronizable属性设置为@YES，这样后Keychain就能被iCloud备份并且跨设备分享。</p>

<p>不过在添加kSecAttrSynchronizable属性后，这条属性会被作为每条Keychain Item的主要的Key之一，所以在搜索，更新，删除的时候如果查询字典内没有这一条属性，item就匹配不到。</p></li>
</ol>


<h2>Keychain Access Group</h2>

<p>Keychain通过provisioning profile来区分不同的应用，provisioning文件内含有应用的bundle id和添加的access groups。不同的应用是完全无法访问其他应用保存在Keychain的信息，除非指定了同样的access group。指定了同样的group名称后，不同的应用间就可以分享保存在Keychain内的信息。</p>

<p>Keychain Access Group的使用方法：</p>

<ol>
<li><p>首先要在Capabilities下打开工程的Keychain Sharing按钮。然后需要分享Keychain的不同应用添   加相同的Group名称。Xcode6以后Group可以随便命名，不需要加AppIdentifierPrefix前缀，并且Xcode会在以entitlements结尾的文件内自动添加所有Group名称，然后在每一个Group前自动加上$(AppIdentifierPrefix)前缀。虽然文档内提到还需要添加一个包含group的.plist文件，其实它和.entitlements文件是同样的作用，所以不需要重复添加。
但是每个不同的应用第一条Group最好以自己的bundleID命名，因为如果entitlements文件内已经有Keychain Access Groups数组后item的Group属性默认就为数组内的第一条Grop。</p></li>
<li><p>需要支持跨设备分享的Keychain item添加一条AccessGroup属性,不过代码里Group名称一定要加上AppIdentifierPrefix前缀。
<code>[searchDictionary setObject:@“AppIdentifierPrefix.UC.testWriteKeychainSuit”     forKey:(id)kSecAttrAccessGroup];</code>
如果要在app内部存私有的信息，group置为自己的bundleID即可，如果entitlements文件内没有指定Keychain Access Groups数组。那group也可以置为nil，这样默认也会以自己的bundleID作为Group。</p></li>
</ol>


<h2>Keychain的安全性</h2>

<p>Keychain内部的数据会自动加密。如果设备没有越狱并且不暴力破解，keychain确实很安全。但是越狱后的设备，keychain就很危险了。</p>

<p>通过上面的一些信息我们已经知道访问keychain里面的数据需要和app一样的证书或者获得access group的名称。设备越狱后相当于对苹果做签名检查的地方打了个补丁，伪造一个证书的app也能正常使用，并且加上Keychain Dumper这些工具获取Keychain内的信息会非常容易。</p>

<h2>使用keychain需要注意的问题</h2>

<ol>
<li>当我们不支持Keychain Access Group，并且没有entitlement文件时，keychain默认以bundle id为group。如果我们在版本更新的时候改变了bundle id，那么新版本就访问不了旧版本的keychain信息了。解决办法是从一开始我们就打开KeychainSharing，添加Keychain Access Group，并且指定每条keychain Item的group，私有的信息就指定app的bundle id为它的group。</li>
<li>代码内Access group名称一定要有AppIdentifierPrefix前缀。</li>
<li>Keychain是基于数据库存储，不允许添加重复的条目。所以每条item都必须指定对应的唯一标识符也就是那些主要的key，如果Key指定不正确，可能会出现添加后查找不到的问题。</li>
<li>kSecAttrSynchronizable也会作为主要的key之一。它的value值默认为No，如果之前添加的item此条属性为YES，在搜索，更新，删除的时候必须添加此条属性才能查找到之前添加的item。</li>
<li>Kechain item字典内添加自定义key时会出现参数不合法的错误。</li>
</ol>


<h2>总结</h2>

<p>keychain很强大，是一个值得利用的工具，我们可以在保存密码或者证书的时候使用keychain，并且支持不同应用分享Keychain内的信息，或者支持iCloud备份跨设备分享，但是越狱版应用还是不建议使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[valueForKey: Vs objectForKey:]]></title>
    <link href="http://blog.sheliw.com/blog/2014/11/26/valueforkey-vs-objectforkey/"/>
    <updated>2014-11-26T19:51:01+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/11/26/valueforkey-vs-objectforkey</id>
    <content type="html"><![CDATA[<p>访问NSDictionary时既可以使用字典内的方法<code>objectForKey:</code>，也可以使用KVC的方法<code>valueForKey:</code>。但是使用这两种方法有什么区别呢？</p>

<ul>
<li><p><code>+ (id)valueForKey:(NSString *)key</code> 的key必须是NSString型，<code>- (id)objectForKey:(id)aKey</code> 的key可以是id类型也就是任何NSObject的子类，不过这个key必须遵循NSCopying协议。</p></li>
<li><p><code>+ (id)valueForKey:(NSString *)key</code>作为一个KVC方法，可以适用于任何类，可以在运行时改变任何类的一个属性。其他语言很少能做到这一点。<code>- (id)objectForKey:(id)aKey</code>只用于NSDictionary或者其子类。</p></li>
<li><p><code>+ (id)valueForKey:(NSString *)key</code>用于NSDictionary时，如果key不包含@,将会调用<code>objectForKey:</code>。如果key包含@，将会调用<code>[super valueForKey:]</code>，这就会导致如果key不存在时将会执行此方法 <code>valueForUndefinedKey:</code>并抛出异常。<code>- (id)objectForKey:(id)aKey</code>在访问NSDictionary里不存在的key时。得到的object为nil。但是不会抛出异常。</p></li>
</ul>


<p>如文档所说：</p>

<blockquote><p><code>valueForKey:</code> Discussion:</p>

<p>If key does not start with “@”, invokes <code>objectForKey:</code>. If key does start with “@”, strips the “@” and invokes <code>[super valueForKey:]</code> with the rest of the key.</p></blockquote>

<p>总之，从速度，安全性方面考虑我们应该在能用<code>objectForKey:</code>的地方就不要用<code>valueForKey:</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[探寻Beacon技术]]></title>
    <link href="http://blog.sheliw.com/blog/2014/11/11/ibeacon/"/>
    <updated>2014-11-11T22:26:32+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/11/11/ibeacon</id>
    <content type="html"><![CDATA[<h2>什么是Beacon?</h2>

<p>Beacon技术最简单的理解可以是一个小型的信息基站，而多个Beacon能构成信息服务网络。Beacon的工作方式是Transmitter-Receiver，即基站-接收机模式的。基站？这个时候不要想到移动、联通的那些大铁塔。这个基站可以是一个运行着Bluetooth 4.0 LE的设备，也可以是经过配置的iPhone、iPad。iPhone4S和之后的iPhone、iPad3或之后的iPad，包括iPad mini都可以配置成Beacon基站。</p>

<h2>Beacon技术的优势</h2>

<p>Beacon技术的优势其实就是低功耗蓝牙的优势。大部分的Beacon硬件连接范围达到200英尺，而且低功耗蓝牙不像WiFi那样需要网络连接，低功耗蓝牙只要有两个点就能运作起来。</p>

<h2>Beacon的应用</h2>

<ol>
<li>零售
通过Beacon向用户推送优惠信息，收集顾客在店内的消费数据。零售店主显然是第一波吃螃蟹的人。</li>
<li>支付
零售业同样是最先开始试水的一支，但这项的使用场景还会扩张。比如当用户进入或者离开一个场地时，自动发起一次支付（用于景点之类的购票）。</li>
<li>交通
机场、火车站、地铁换乘站针对乘客的信息推送。目前只是换乘、导航、天气信息，但未来可以发展成行程服务信息，比如当乘客到达后自动打车。</li>
<li>家居
同样是基于地理围栏的信息通知，比如告诉父母孩子回到家里了。</li>
</ol>


<h2>Beacon设备的技术原理</h2>

<p>一个Beacon基站主要有三部分标识：</p>

<ol>
<li>UUID，形如：206A2476-D4DB-42F0-BF73-030236F2C756。用来标识某一个公司。比如，某个房地产公司的全部的基站都用同一个UUID。</li>
<li>major，用来标识某一类的beacon。比如这个房地产公司的北京的房子都设定为1，上海的都设定为2。</li>
<li>minor，用来标识某一个特定的beacon。比如某栋楼的某个基站。</li>
</ol>


<p>Beacon设备发送信号成为一个Beacon基站。然后另一个设备比如iPhone可以用一款App来监听附近某个UUID的Beacon基站，就算程序被关闭后，如果iPhone在附近发现此UUID的Beacon基站，App就能被唤醒，并且在iPhone锁屏界面的右下角会出现App的小图标。</p>

<p>一般情况下如果一个商场在自己商场里面铺设很多的Beacon基站。所有Beacon的UUID应该是一样的。同一楼层Beacon基站的major可以一样，同一商店Beacon的minor值一样。</p>

<h2>Beacon在IOS设备上的实现</h2>

<p>Beacon需要CoreBluetooth.framework和CoreLocation.framework两个framework,先把他们加到项目中。</p>

<h4>发送Beacon信号：</h4>

<pre><code>
self.peripheralManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil options:nil];

time_t t;
srand((unsigned) time(&t));
CLBeaconRegion *region = [[CLBeaconRegion alloc] initWithProximityUUID:self.beaconRegion.proximityUUID major:rand() minor:rand() identifier:self.beaconRegion.identifier];

NSDictionary *beaconPeripheralData = [region peripheralDataWithMeasuredPower:nil];
[self.peripheralManager startAdvertising:beaconPeripheralData];
</code></pre>


<h6>需要实现CoreBluetooth里的CBPeripheralManagerDelegate的代理方法</h6>

<pre><code>
//pragma mark - Beacon advertising delegate methods
- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheralManager error:(NSError *)error
{
    if (error) {
        NSLog(@"Couldn't turn on advertising: %@", error);
        return;
    }
    
    if (peripheralManager.isAdvertising) {
    }
}

- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheralManager
{
    if (peripheralManager.state != CBPeripheralManagerStatePoweredOn) {
        NSLog(@"Peripheral manager is off.");
        return;
    }

    NSLog(@"Peripheral manager is on.");
}
</code></pre>


<h4>监控附近的Beacon基站</h4>

<pre><code>
self.locationManager = [[CLLocationManager alloc] init];
self.locationManager.delegate = self;

//kUUID可以设置为一个定值，就是监控附近为此UUID的beacon设备。

NSUUID *proximityUUID = [[NSUUID alloc] initWithUUIDString:kUUID];
self.beaconRegion = [[CLBeaconRegion alloc] initWithProximityUUID:proximityUUID identifier:kIdentifier];
self.beaconRegion.notifyEntryStateOnDisplay = YES;

//开始接收
[self.locationManager startMonitoringForRegion:self.beaconRegion];

//停止接收
[self.locationManager stopMonitoringForRegion:self.beaconRegion];
</code></pre>


<h6>需要实现CoreLocation里的CLLocationManagerDelegate的代理方法</h6>

<pre><code>
//程序会不断调用此方法，beacons包含所有发现的Beacon基站
- (void)locationManager:(CLLocationManager *)manager
        didRangeBeacons:(NSArray *)beacons
               inRegion:(CLBeaconRegion *)region {
}

//进入beacon区域
- (void)locationManager:(CLLocationManager *)manager didEnterRegion:(CLRegion *)region
{
    NSLog(@"Entered region: %@", region);
}

//出beacon区域
- (void)locationManager:(CLLocationManager *)manager didExitRegion:(CLRegion *)region
{
    NSLog(@"Exited region: %@", region);
}

//在上面两个方法被调用之后调用
- (void)locationManager:(CLLocationManager *)manager didDetermineState:(CLRegionState)state forRegion:(CLRegion *)region
{
   
}
</code></pre>


<h4>接受Beacon基站发送的信息</h4>

<pre><code>
self.locationManager = [[CLLocationManager alloc] init];
self.locationManager.delegate = self;

NSUUID *proximityUUID = [[NSUUID alloc] initWithUUIDString:kUUID];
self.beaconRegion = [[CLBeaconRegion alloc] initWithProximityUUID:proximityUUID identifier:kIdentifier];
self.beaconRegion.notifyEntryStateOnDisplay = YES;

//接受Beacon基站的推送信息
[self.locationManager startRangingBeaconsInRegion:self.beaconRegion];
//停止Beacon基站的推送信息
[self.locationManager stopRangingBeaconsInRegion:self.beaconRegion];
</code></pre>


<h3>参考</h3>

<p>iBeacon的一些介绍：<a href="http://www.cocoachina.com/industry/20140730/9275.html">iBeacon 的第一篇（基于Swift实现）</a></p>

<p>Github开源项目<a href="https://github.com/nicktoumpelis/HiBeacons">HiBeacons</a></p>

<p>苹果官方iBeacon例子<a href="https://developer.apple.com/library/ios/samplecode/airlocate/introduction/intro.html">AirLocate: Using CoreLocation to monitor, range, and configure your device as an iBeacon</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用XIB设置视图的更多属性]]></title>
    <link href="http://blog.sheliw.com/blog/2014/10/25/ru-he-shi-yong-xibshe-zhi-shi-tu-de-geng-duo-shu-xing/"/>
    <updated>2014-10-25T13:37:20+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/10/25/ru-he-shi-yong-xibshe-zhi-shi-tu-de-geng-duo-shu-xing</id>
    <content type="html"><![CDATA[<p>最近遇到了将ScrollView放在XIB的视图里，用代码设置contentSize后，scrollView不能滑动的问题。费了很大劲之后找到正确的办法，并且发现XIB的一个极为实用的技巧。如果想用XIB设置视图更多的属性。可以使用Identity inspector下的User Defined Runtime Attribute.添加一些KeyPath.</p>

<p>1.在XIB里选中视图。</p>

<p>2.切换到Identity inspector, 新建一个新的User Defined Runtime Attribute (点击  + 按钮)。</p>

<p>3.双击Key Path,改为要设置的属性。</p>

<p>4.双击Type，改为要设置的属性的类型.</p>

<p>5.更改Value为要设置的值。</p>

<p>Swift语言貌似可以使用@IBInspectable和@IBDesignable 直接在Storyboard和Xib里添加设置选项</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[正方教务管理系统IOS客户端]]></title>
    <link href="http://blog.sheliw.com/blog/2014/10/25/zheng-fang-jiao-wu-guan-li-xi-tong-ioske-hu-duan/"/>
    <updated>2014-10-25T13:16:47+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/10/25/zheng-fang-jiao-wu-guan-li-xi-tong-ioske-hu-duan</id>
    <content type="html"><![CDATA[<p>最近和朋友一起做完了学校的教务系统iOS客户端，这里写一下我遇到的一些问题和心得。</p>

<h3>用到的几个工具</h3>

<ol>
<li>chrome的开发者工具   查看每次HTTP请求命令与参数等。</li>
<li>AFNetworking    ios网络请求开源框架，同样的有ASIHttprequest。选择AFnetworking是因为它更简单，并且现在还在更新维护，ASI好像好久没有更新。</li>
<li>TFhepple    Html分析类库。</li>
</ol>


<h3>编码</h3>

<p>正方教务系统因为没有对应的JSON或者XML数据接口，所以只能模拟网页的所有行为，获取html 分析html。
正方教务系统用的编码是GB2312 框架获取下来的NSString虽然已经自动解码，但是很不稳定，有时候会得到空字符串，但是获取下来的DATA就没有这个问题，所以就要手动解码将DATA转为NSString。</p>

<pre><code>NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000);                 
NSData *data=responseObject;
NSString *transStr=[[NSString alloc]initWithData:data encoding:enc];&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>光转码也不行，在分析HTML的时候因为网页头部的编码信息也有问题，所以要做手动修改，这样才能被TFhepple正确解
析。</p>

<pre><code> 
 NSString *utf8HtmlStr = [transStr stringByReplacingOccurrencesOfString:@"http-equiv=\"Content-Type\" content=\"text/html; charset=gb2312\">" withString:@"http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">"];
NSData *htmlDataUTF8 = [utf8HtmlStr dataUsingEncoding:NSUTF8StringEncoding];
TFHpple *xpathParser = [[TFHpple alloc]initWithHTMLData:htmlDataUTF8];</code></pre>


<p>
成绩页面修改的方式有所不同</p>

<pre><code>
NSString *utf8HtmlStr = [transStr stringByReplacingOccurrencesOfString:@"content=\"text/html; charset=gb2312\" http-equiv=\"Content-Type\">" withString:@"http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">"];</code></pre>


<p>其他页面要怎么替换具体要看页面头部具体的信息是什么，然后写在 stringByReplacingOccurrencesOfString方法第一个参数部分就可以。</p>

<h3>模拟登陆</h3>

<p>模拟登陆第一步要获取Cookie，这个用 NSURLRequest就能获取到，之后要在每次请求的时候加到 NSMutableURLRequest 里。AFnetworking在每次请求的时候都会建立一个NSURLRequest对象，改这个就可以。代码如下
获取cookie</p>

<pre><code> 
 NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"
http://学校的网址/default2.aspx"]];
//  cachePolicy:NSURLRequestReloadIgnoringLocalAndRemoteCacheData
                                            //timeoutInterval:3];
[NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];
NSHTTPCookieStorage *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage];
NSArray *cookies =[cookieJar cookies];
_cookieDictionary= [NSHTTPCookie requestHeaderFieldsWithCookies:cookies];
</code></pre>


<p>
获取验证码的时候必须带上cookie,每次post或者get需要带上的是登陆成功后保存下来的cookie。</p>

<pre><code> 
- (AFHTTPRequestOperation *)POST:(NSString *)URLString
                      parameters:(NSDictionary *)parameters
                         success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
                         failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure
{
    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:@"POST" URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:nil];
    if(self.cookieDictionary) {
        [request setHTTPShouldHandleCookies:NO];
        [request setAllHTTPHeaderFields:self.cookieDictionary];
    }
</code></pre>


<p></p>

<p>模拟登陆提交的参数有 用户名,密码，验证码还有一个viewstate，这个viewstate每次都得在登陆前获取验证码图片的时候同时获取 还是通过GET请求得到页面通过html分析工具得到对应的viwestate，具体可以看我的DEMO.然后在提交参数的时候一并提
交。</p>

<pre><code> 
NSDictionary *parameters = @{@"__VIEWSTATE":self.viewState,@"txtUserName"self.xueHao.text,@"TextBox2":self.miMa.text,@"txtSecretCode":self.yanZhengMa.text,@"RadioButtonList1":@"学生",@"Button1":@""};
</code></pre>


<p>
登陆成功之后就可以用cookie随意访问各个页面了。。不过在请求查询成绩页面的时候还要提交一个viewState,这个viewState参数是从登陆成功后的第一个页面获取，Very long。
并且在访问内部所有页面的时候都要在Request Header里加一个refer参数，这个参数跟提交cookie是一样的道理，学校的系统这个东西不提交不行，但是随便提交一个任何人的页面地址居然就可以了。这部分也是加在AFHTTPRequestOperationManager类里实现文件post 和get 方法底下。</p>

<pre><code> 
   if(self.cookieDictionary) {
        NSMutableDictionary *newDictionary=[self.cookieDictionary mutableCopy];
        [newDictionary setValue:@"http://gdjwgl.bjut.edu.cn/xs_main.aspx?xh=11111111" forKey:@"Referer"];
        [request setAllHTTPHeaderFields:newDictionary];   
    }
</code></pre>


<p></p>

<p>demo地址：<a href="https://github.com/zqpmaster/FangZhengJiaoWU">正方教务系统iOS客户端Demo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在Cocos2d-x游戏里集成iAd广告]]></title>
    <link href="http://blog.sheliw.com/blog/2014/10/25/ru-he-zai-cocos2d-xyou-xi-li-ji-cheng-iadyan-gao/"/>
    <updated>2014-10-25T12:54:03+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/10/25/ru-he-zai-cocos2d-xyou-xi-li-ji-cheng-iadyan-gao</id>
    <content type="html"><![CDATA[<p>1) Link binary with iAd.framework<a href="https://developer.apple.com/library/ios/#recipes/xcode_help-project_editor/Articles/AddingaLibrarytoaTarget.html">https://developer.apple.com/library/ios/#recipes/xcode_help-project_editor/Articles/AddingaLibrarytoaTarget.html</a></p>

<pre><code>1. In the project navigator, select your project
2. Select your target
3.  Select the 'Build Phases' tab
4.  Open 'Link Binaries With Libraries' expander    5.  Click the '+' button
6.  Select iAd.framework
</code></pre>

<p>2) Download iAdSuite<a href="https://developer.apple.com/library/ios/#samplecode/iAdSuite/Introduction/Intro.html">https://developer.apple.com/library/ios/#samplecode/iAdSuite/Introduction/Intro.html</a> and copy files BannerViewController.h and BannerViewController.m from ContainerBanner project to your project.</p>

<p>3) Modify AppController.mm, add</p>

<pre><code>&lt;code&gt;&lt;pre&gt;#import "BannerViewController.h"&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>and replace</p>

<pre><code>@implementationAppController
</code></pre>

<p>with</p>

<pre><code>@implementationAppController
{
    BannerViewController*_bannerViewController;
}
</code></pre>

<p>and</p>

<pre><code>// Set RootViewController to window
if([[UIDevicecurrentDevice].systemVersionfloatValue]&lt; 6.0)
{
//
 warning: addSubView doesn't work on iOS6
    [window addSubview:viewController.view];
}else
{
//use this method on ios6
    [window setRootViewController:viewController];
}
</code></pre>

<p>with</p>

<pre><code>_bannerViewController=[[BannerViewController alloc]initWithContentViewController:viewController];
window.rootViewController=_bannerViewController;
</code></pre>

<p>4) Modify RootViewController.mm, add</p>

<pre><code>#import"BannerViewController.h"
</code></pre>

<p>and replace
<code><pre>
/<em>
//The designated initializer.  Override if you create the controller programmatically and want to perform customization that is not appropriate for viewDidLoad.
-(id)initWithNibName:(NSString </em>)nibNameOrNil bundle:(NSBundle <em>)nibBundleOrNil {
 if((self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil])) {
//Custom initialization
}
 return self;
}
</em>/
</code></pre>
with
<code><pre>
-(id)initWithNibName:(NSString<em>)nibNameOrNil bundle:(NSBundle</em>)nibBundleOrNil
 {
    if((self=[super initWithNibName:nibNameOrNil bundle:nibBundleOrNil])){
        [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(willBeginBannerViewActionNotification:)    name:BannerViewActionWillBegin object:nil];
        [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(didFinishBannerViewActionNotification:)name:BannerViewActionDidFinisho bject:nil];
}
    return self;
}
</code></pre></p>

<p>and add the following methods
<code><pre>
-(void)willBeginBannerViewActionNotification:(NSNotification<em>)notification{
    NSLog(@&ldquo;willBeginBannerViewActionNotification&rdquo;);
}
-(void)didFinishBannerViewActionNotification:(NSNotification</em>)notification
{
    NSLog(@&ldquo;didFinishBannerViewActionNotification&rdquo;);
}
</code></pre></p>

<p>In willBeginBannerViewActionNotification you can pause your game before the banner view triggers an advertising action. In didFinishBannerViewActionNotification you can resume your game when control is returned to it.</p>

<p>BannerViewController changes EAGLView size when banner becomes visible. If you use it like that, cocos2d-x may not detect touch location correctly. Here are the modifications to BannerViewController.m required to display ADBannerView on top of EAGLView.</p>

<p>1) Edit loadView method and put line</p>

<pre><code>[contentView addSubview:_bannerView];
</code></pre>

<p>after</p>

<pre><code>[contentView addSubview:_contentController.view];
</code></pre>

<p>loadView should look like this:
<code><pre>
-(void)loadView
{
    UIView *contentView=[[UIView alloc]initWithFrame[[UIScreen mainScreen]bounds]];
   [self addChildViewController:<em>contentController];
   [contentView addSubview:</em>contentController.view];
   [<em>contentController didMoveToParentViewController:self];
   [contentView addSubview:</em>bannerView];
   self.view=contentView;
}</code></pre>
2) Edit viewDidLayoutSubviews method and replace
<code><pre>
if(<em>bannerView.bannerLoaded)
 {
    contentFrame.size.height-=bannerFrame.size.height;
    bannerFrame.origin.y=contentFrame.size.height;
}else{
   bannerFrame.origin.y=contentFrame.size.height;
}
</code></pre>
with
<code><pre>
if(</em>bannerView.bannerLoaded)
 {
    bannerFrame.origin.y=0;
}else{
    bannerFrame.origin.y= -bannerFrame.size.height;
}
</code></pre>
P.S. Are you sure you want to use iAd? Besides low fill rate, there are some limitations. For instance, Apple’s policy is not to serve iAd advertisements to applications that are designed for children as stated at <a href="https://developer.apple.com/support/ios/iad-network.html.">https://developer.apple.com/support/ios/iad-network.html.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSOperationQueue与GCD的区别]]></title>
    <link href="http://blog.sheliw.com/blog/2014/10/11/nsoperationqueue-vs-gcd/"/>
    <updated>2014-10-11T10:49:58+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/10/11/nsoperationqueue-vs-gcd</id>
    <content type="html"><![CDATA[<p>首先，我们要明确NSOperationQueue与GCD之间的关系</p>

<p>NSOpertaionQueue用GCD构建封装的，是GCD的高级抽象。
其次，我们要区别两者的不同</p>

<p>GCD仅仅支持FIFO队列，而NSOperationQueue中的队列可以被重新设置优先级，从而实现不同操作的执行顺序调整。
GCD不支持异步操作之间的依赖关系设置。如果某个操作的依赖另一个操作的数据（生产者-消费者模型是其中之一），使用NSOperationQueue能够按照正确的顺序执行操作。GCD则没有内建的依赖关系支持。</p>

<p>NSOperationQueue支持KVO，意味着我们可以观察任务的执行状态。</p>

<p>了解以上不同，我们可以从以下角度来定义原则</p>

<ol>
<li><p>性能
GCD更接近底层，而NSOperationQueue则更高级抽象，所以GCD在追求性能的底层操作来说，是速度最快的。这取决于使用Instruments进行代码性能分析，如有必要的话</p></li>
<li><p>从异步操作之间的事务性，顺序行，依赖关系，任务并发数量，任务优先级。GCD需要自己写更多的代码来实现，而NSOperationQueue已经内建了这些支持</p></li>
<li><p>如果异步操作的过程需要更多的被交互和UI呈现出来，NSOperationQueue会是一个更好的选择。底层代码中，任务之间不太互相依赖，而需要更高的并发能力，GCD则更有优势</p></li>
</ol>


<p>最后的一句话
别忘了高德纳的教诲：“在大概97%的时间里，我们应该忘记微小的性能提升。过早优化是万恶之源。”只有Instruments显示有真正的性能提升时才有必要用低级的GCD。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block, weakSelf and strongSelf]]></title>
    <link href="http://blog.sheliw.com/blog/2014/10/04/block/"/>
    <updated>2014-10-04T15:07:23+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/10/04/block</id>
    <content type="html"><![CDATA[<p>Block is powerful in Objective-C. But there is a very stupid problem called cyclic retention pitfall, that a block locked an object so that the object will never be release.</p>

<p>For example, in the function:</p>

<pre><code>
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    [self doSomething];
    [self doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>


<p>When the block is created, the compiler will capture all objects that used inside the block and add reference count by 1. In this case, self will be locked and so the object will not be released until the block is finished. Note that cyclic retention pitfall is not only happened in self object, but in 99% case, it happens in self object.</p>

<h2>Weakify</h2>

<p>To solve the problem, we can simply create a weak reference of the self, and use the weak object instead of the original object inside block. When the weak object is used, the block will not increase the reference count, so self will not be locked. We call to weakify the self.</p>

<pre><code>
__weak __typeof__(self) weakSelf = self;
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    [weakSelf doSomething];
    [weakSelf doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>


<h2>When should use weakify</h2>

<p>The block will release all objects used inside the blocks scope after the block is finished. If the block is execution type block that will be released after execution is finished, e.g.:</p>

<ul>
<li>GCD dispatch block</li>
<li>Most UIKit block</li>
</ul>


<p>It should be safe not to use weakify technique because the block&rsquo;s lifetime is determined. However, if you are using block that will store block as variable, e.g.:</p>

<ul>
<li>Blocks in NSOperation, AFHTTPRequestOperation</li>
<li>Event handler block like something in BlocksKit</li>
</ul>


<p>Because the lifetime of the block is uncertained, it is suggested to use weakify to prevent cyclic retention pitfall.</p>

<p>Use AFHTTPRequestOperation as an example, if you simple call:</p>

<pre><code>
AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];
op.responseSerializer = [AFJSONResponseSerializer serializer];
[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
    [self doSomethingUpdateControls];
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
[op start];
</code></pre>


<p>self will be locked until the network operation finished. It may be okay in most case because it will at most cost several seconds to complete the operation.</p>

<p>But, if you are handling operations using operation queue:</p>

<pre><code>
AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];
op.responseSerializer = [AFJSONResponseSerializer serializer];
[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
    [self doSomethingUpdateControls];
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
[[NSOperationQueue mainQueue] addOperation:op];
</code></pre>


<p>There will be chance that the operation will be paused in the queue. When the operation object is not released, it will lock the block scope and so theself object. In this case, if the self object is a viewController and if you don&rsquo;t want to use weakify technique, you must make sure that you have to cancel all operations
[[NSOperationQueue mainQueue] removeAllOperations] at some point like [viewDidDisappeared:(BOOL)animated].</p>

<h2>Strongify</h2>

<p>But there is another problem, because now the self is weakified. Now self will be free and weakSelf can be nil any time. In the above case, the block may able to run doSomething but failed to run doMoreThing because weakSelf may be nullified at that time.</p>

<p>To solve this, we can strongify self before use:</p>

<pre><code>
__weak __typeof__(self) weakSelf = self;
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    __strong __typeof__(self) strongSelf = weakSelf;
    [strongSelf doSomething];
    [strongSelf doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>


<p>So self will not be released inside the block call until the life cycle of the strongSelf ends.</p>

<h2>When should use strongify</h2>

<p>However, should we use strongSelf every time inside a block?</p>

<p>Yes, it’s safe to use it every time.</p>

<p>No, sometimes you can simply use the weakSelf when:</p>

<ul>
<li>You don&rsquo;t care that self will be nullified in the middle of the block. e.g. setting control’s value. Note that although weakSelf may be released in the middle, it will be nullified and will not crash the code.</li>
<li>You are sure that the self will not be released in the middle. e.g. All block are running in main thread.</li>
</ul>


<h2>Syntax Sugar</h2>

<p>We can use a third party library libextobjc so that you can some more readable code like this:</p>

<pre><code>
@weakify(self);
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    @strongify(self);   
    [self doSomething];
    [self doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在Xcode5中完整更改iOS工程的名称]]></title>
    <link href="http://blog.sheliw.com/blog/2014/09/08/ru-he-wan-zheng-geng-gai-xcode5zhong-iosde-gong-cheng-ming-zi/"/>
    <updated>2014-09-08T18:18:49+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/09/08/ru-he-wan-zheng-geng-gai-xcode5zhong-iosde-gong-cheng-ming-zi</id>
    <content type="html"><![CDATA[<p>在用Xcode开发软件的时候难免会碰到项目更名的时候，重新更名目标名还是比较方便的，如何正确的更改「xcodeproj」的项目名还有对应的目录名字呢？</p>

<p>首先要做的是备份一下整个工程文件，防止一旦更名失败还有办法补救，不然一切都毁了。</p>

<p>更名很简单，只要选中Project，按回车，就可以重命名了，也可以在右边工具栏那里进行：</p>

<p>在输入了新的名字以后，Xcode会智能的提示你，是否要把所有项目相关的名称也给重命名了，选择「Rename」。</p>

<p>做完这一步后，原来的project文件夹，已经变成新名字了，与此对应还有一些其他文件的内容。还没有完，还有一个大文件夹还是老名字：接下去把Group的名字也已相同的方式重命名。</p>

<p>但是它不会自动也重命名整个Folder，这时，访问文件，手动将所有相关的文件夹重命名，除了.xcodeproj所在的目录名字，这个后面再改，然后Xcode会出现一大堆文件丢失，先不要理他，继续选中Group的名字，然后点击右边那个文件夹，就会出现一个「Choose a location」，选中新命名的文件夹来代表就可以了。</p>

<p>这时如果编译的话，会提示Info.plist找不到，需要选中Target，然后点击那个「Choose Info.plist File&hellip;」，选择之前被重命名的Info.plist文件即可。</p>

<p>做完这步后，按Command +shift +f全局搜索老工程名，除了所有类里面的注释以外 还有一些编译 build路径等，把这些都改为新工程名。类里边头部的注释就可改可不改了。</p>

<p>这时候编译还是无法通过，提示有文件找不到，其中还是引用了老的目录。这时就只好人工去修改文件 .xcodeproj 文件目录下的「project.pbxproj」文件了，里面还有几个字段是老工程名，全部替换成新工程名，然后这时候去更改.xcodeproj所在的目录名字，这样基本就大功告成了，如果还提示missing file等警告 可以通过移动目录，删除对应SVN文件等方式解决。</p>

<p>这样，重构项目很重要的一步：重命名项目和目录名，就这样完成了。</p>

<p>补充：xcodeproj/xcuserdata 及 xcodeproj/project.xcworkspace/ 都是用户及工作区的数据，版本控制时要ignore掉，特别是多人开发的情况下。</p>
]]></content>
  </entry>
  
</feed>
