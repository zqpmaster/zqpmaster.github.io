<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Max Blog]]></title>
  <link href="http://blog.sheliw.com/atom.xml" rel="self"/>
  <link href="http://blog.sheliw.com/"/>
  <updated>2014-12-04T12:57:49+08:00</updated>
  <id>http://blog.sheliw.com/</id>
  <author>
    <name><![CDATA[一切从简]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[valueForKey: Vs objectForKey:]]></title>
    <link href="http://blog.sheliw.com/blog/2014/11/26/valueforkey-vs-objectforkey/"/>
    <updated>2014-11-26T19:51:01+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/11/26/valueforkey-vs-objectforkey</id>
    <content type="html"><![CDATA[<p>访问NSDictionary时既可以使用字典内的方法<code>objectForKey:</code>，也可以使用KVC的方法<code>valueForKey:</code>。但是使用这两种方法有什么区别呢？</p>

<ul>
<li><p><code>+ (id)valueForKey:(NSString *)key</code> 的key必须是NSString型，<code>- (id)objectForKey:(id)aKey</code> 的key可以是id类型也就是任何NSObject的子类，不过这个key必须遵循NSCopying协议。</p></li>
<li><p><code>+ (id)valueForKey:(NSString *)key</code>作为一个KVC方法，可以适用于任何类，可以在运行时改变任何类的一个属性。其他语言很少能做到这一点。<code>- (id)objectForKey:(id)aKey</code>只用于NSDictionary或者其子类。</p></li>
<li><p><code>+ (id)valueForKey:(NSString *)key</code>用于NSDictionary时，如果key不包含@,将会调用<code>objectForKey:</code>。如果key包含@，将会调用<code>[super valueForKey:]</code>，这就会导致如果key不存在时将会执行此方法 <code>valueForUndefinedKey:</code>并抛出异常。<code>- (id)objectForKey:(id)aKey</code>在访问NSDictionary里不存在的key时。得到的object为nil。但是不会抛出异常。</p></li>
</ul>


<p>如文档所说：</p>

<blockquote><p><code>valueForKey:</code> Discussion:</p>

<p>If key does not start with “@”, invokes <code>objectForKey:</code>. If key does start with “@”, strips the “@” and invokes <code>[super valueForKey:]</code> with the rest of the key.</p></blockquote>

<p>总之，从速度，安全性方面考虑我们应该在能用<code>objectForKey:</code>的地方就不要用<code>valueForKey:</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[探寻Beacon技术]]></title>
    <link href="http://blog.sheliw.com/blog/2014/11/11/ibeacon/"/>
    <updated>2014-11-11T22:26:32+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/11/11/ibeacon</id>
    <content type="html"><![CDATA[<p>最近有幸研究一番Beacon，并且也和生产Beacon设备的厂家交流了一些关于Beacon的技术。苹果没有使用NFC，而是选择了Beacon自有一定的道理。</p>

<h2>什么是Beacon?</h2>

<p>Beacon技术最简单的理解可以是一个小型的信息基站，而多个Beacon能构成信息服务网络。Beacon的工作方式是Transmitter-Receiver，即基站-接收机模式的。基站？这个时候不要想到移动、联通的那些大铁塔。这个基站可以是一个运行着Bluetooth 4.0 LE的设备，也可以是经过配置的iPhone、iPad。iPhone4S和之后的iPhone、iPad3或之后的iPad，包括iPad mini都可以配置成Beacon基站。</p>

<h2>Beacon技术的优势</h2>

<p>Beacon技术的优势其实就是低功耗蓝牙的优势。大部分的Beacon硬件连接范围达到200英尺，而且低功耗蓝牙不像WiFi那样需要网络连接，低功耗蓝牙只要有两个点就能运作起来。</p>

<h2>Beacon的应用</h2>

<ol>
<li>零售
通过Beacon向用户推送优惠信息，收集顾客在店内的消费数据。零售店主显然是第一波吃螃蟹的人。</li>
<li>支付
零售业同样是最先开始试水的一支，但这项的使用场景还会扩张。比如当用户进入或者离开一个场地时，自动发起一次支付（用于景点之类的购票）。</li>
<li>交通
机场、火车站、地铁换乘站针对乘客的信息推送。目前只是换乘、导航、天气信息，但未来可以发展成行程服务信息，比如当乘客到达后自动打车。</li>
<li>家居
同样是基于地理围栏的信息通知，比如告诉父母孩子回到家里了。</li>
</ol>


<h2>Beacon设备的技术原理</h2>

<p>一个Beacon基站主要有三部分标识：</p>

<ol>
<li>UUID，形如：206A2476-D4DB-42F0-BF73-030236F2C756。用来标识某一个公司。比如，某个房地产公司的全部的基站都用同一个UUID。</li>
<li>major，用来标识某一类的beacon。比如这个房地产公司的北京的房子都设定为1，上海的都设定为2。</li>
<li>minor，用来标识某一个特定的beacon。比如某栋楼的某个基站。</li>
</ol>


<p>Beacon设备发送信号成为一个Beacon基站。然后另一个设备比如iPhone可以用一款App来监听附近某个UUID的Beacon基站，就算程序被关闭后，如果iPhone在附近发现此UUID的Beacon基站，App就能被唤醒，并且在iPhone锁屏界面的右下角会出现App的小图标。</p>

<p>一般情况下如果一个商场在自己商场里面铺设很多的Beacon基站。所有Beacon的UUID应该是一样的。同一楼层Beacon基站的major可以一样，同一商店Beacon的minor值一样。</p>

<h2>Beacon在IOS设备上的实现</h2>

<p>Beacon需要CoreBluetooth.framework和CoreLocation.framework两个framework,先把他们加到项目中。</p>

<h4>发送Beacon信号：</h4>

<pre><code>
self.peripheralManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil options:nil];

time_t t;
srand((unsigned) time(&t));
CLBeaconRegion *region = [[CLBeaconRegion alloc] initWithProximityUUID:self.beaconRegion.proximityUUID major:rand() minor:rand() identifier:self.beaconRegion.identifier];

NSDictionary *beaconPeripheralData = [region peripheralDataWithMeasuredPower:nil];
[self.peripheralManager startAdvertising:beaconPeripheralData];
</code></pre>


<h6>需要实现CoreBluetooth里的CBPeripheralManagerDelegate的代理方法</h6>

<pre><code>
//pragma mark - Beacon advertising delegate methods
- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheralManager error:(NSError *)error
{
    if (error) {
        NSLog(@"Couldn't turn on advertising: %@", error);
        return;
    }
    
    if (peripheralManager.isAdvertising) {
    }
}

- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheralManager
{
    if (peripheralManager.state != CBPeripheralManagerStatePoweredOn) {
        NSLog(@"Peripheral manager is off.");
        return;
    }

    NSLog(@"Peripheral manager is on.");
}
</code></pre>


<h4>监控附近的Beacon基站</h4>

<pre><code>
self.locationManager = [[CLLocationManager alloc] init];
self.locationManager.delegate = self;

//kUUID可以设置为一个定值，就是监控附近为此UUID的beacon设备。

NSUUID *proximityUUID = [[NSUUID alloc] initWithUUIDString:kUUID];
self.beaconRegion = [[CLBeaconRegion alloc] initWithProximityUUID:proximityUUID identifier:kIdentifier];
self.beaconRegion.notifyEntryStateOnDisplay = YES;

//开始接收
[self.locationManager startMonitoringForRegion:self.beaconRegion];

//停止接收
[self.locationManager stopMonitoringForRegion:self.beaconRegion];
</code></pre>


<h6>需要实现CoreLocation里的CLLocationManagerDelegate的代理方法</h6>

<pre><code>
//程序会不断调用此方法，beacons包含所有发现的Beacon基站
- (void)locationManager:(CLLocationManager *)manager
        didRangeBeacons:(NSArray *)beacons
               inRegion:(CLBeaconRegion *)region {
}

//进入beacon区域
- (void)locationManager:(CLLocationManager *)manager didEnterRegion:(CLRegion *)region
{
    NSLog(@"Entered region: %@", region);
}

//出beacon区域
- (void)locationManager:(CLLocationManager *)manager didExitRegion:(CLRegion *)region
{
    NSLog(@"Exited region: %@", region);
}

//在上面两个方法被调用之后调用
- (void)locationManager:(CLLocationManager *)manager didDetermineState:(CLRegionState)state forRegion:(CLRegion *)region
{
   
}
</code></pre>


<h4>接受Beacon基站发送的信息</h4>

<pre><code>
self.locationManager = [[CLLocationManager alloc] init];
self.locationManager.delegate = self;

NSUUID *proximityUUID = [[NSUUID alloc] initWithUUIDString:kUUID];
self.beaconRegion = [[CLBeaconRegion alloc] initWithProximityUUID:proximityUUID identifier:kIdentifier];
self.beaconRegion.notifyEntryStateOnDisplay = YES;

//接受Beacon基站的推送信息
[self.locationManager startRangingBeaconsInRegion:self.beaconRegion];
//停止Beacon基站的推送信息
[self.locationManager stopRangingBeaconsInRegion:self.beaconRegion];
</code></pre>


<h3>参考</h3>

<p>iBeacon的一些介绍：<a href="http://www.cocoachina.com/industry/20140730/9275.html">iBeacon 的第一篇（基于Swift实现）</a></p>

<p>Github开源项目<a href="https://github.com/nicktoumpelis/HiBeacons">HiBeacons</a></p>

<p>苹果官方iBeacon例子<a href="https://developer.apple.com/library/ios/samplecode/airlocate/introduction/intro.html">AirLocate: Using CoreLocation to monitor, range, and configure your device as an iBeacon</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用XIB设置视图的更多属性]]></title>
    <link href="http://blog.sheliw.com/blog/2014/10/25/ru-he-shi-yong-xibshe-zhi-shi-tu-de-geng-duo-shu-xing/"/>
    <updated>2014-10-25T13:37:20+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/10/25/ru-he-shi-yong-xibshe-zhi-shi-tu-de-geng-duo-shu-xing</id>
    <content type="html"><![CDATA[<p>最近遇到了将ScrollView放在XIB的视图里，用代码设置contentSize后，scrollView不能滑动的问题。费了很大劲之后找到正确的办法，并且发现XIB的一个极为实用的技巧。如果想用XIB设置视图更多的属性。可以使用Identity inspector下的User Defined Runtime Attribute.添加一些KeyPath.</p>

<p>1.在XIB里选中视图。</p>

<p>2.切换到Identity inspector, 新建一个新的User Defined Runtime Attribute (点击  + 按钮)。</p>

<p>3.双击Key Path,改为要设置的属性。</p>

<p>4.双击Type，改为要设置的属性的类型.</p>

<p>5.更改Value为要设置的值。</p>

<p>Swift语言貌似可以使用@IBInspectable和@IBDesignable 直接在Storyboard和Xib里添加设置选项</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[正方教务管理系统IOS客户端]]></title>
    <link href="http://blog.sheliw.com/blog/2014/10/25/zheng-fang-jiao-wu-guan-li-xi-tong-ioske-hu-duan/"/>
    <updated>2014-10-25T13:16:47+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/10/25/zheng-fang-jiao-wu-guan-li-xi-tong-ioske-hu-duan</id>
    <content type="html"><![CDATA[<h2>正方教务系统IOS客户端DEMO</h2>

<p>用到的几个工具</p>

<pre><code>- chrome的开发者工具   查看每次HTTP请求命令与参数等。
- AFNetworking    ios网络请求开源框架，同样的有ASIHttprequest。选择AFnetworking是因为它更简单，并且现在还在更新维护，ASI好像好久没有更新。
- TFhepple    Html分析类库。
</code></pre>

<p>正方教务系统因为没有对应的JSON或者XML数据接口，所以只能模拟网页的所有行为，获取html 分析html。
正方教务系统用的编码是GB2312 框架获取下来的NSString虽然已经自动解码，但是很不稳定，有时候会得到空字符串，但是获取下来的DATA就没有这个问题，所以就要手动解码将DATA转为NSString。</p>

<pre><code>NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000);                 
NSData *data=responseObject;
NSString *transStr=[[NSString alloc]initWithData:data encoding:enc];&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>光转码也不行，在分析HTML的时候因为网页头部的编码信息也有问题，所以要做手动修改，这样才能被TFhepple正确解
析。</p>

<pre><code> 
 NSString *utf8HtmlStr = [transStr stringByReplacingOccurrencesOfString:@"http-equiv=\"Content-Type\" content=\"text/html; charset=gb2312\">" withString:@"http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">"];
NSData *htmlDataUTF8 = [utf8HtmlStr dataUsingEncoding:NSUTF8StringEncoding];
TFHpple *xpathParser = [[TFHpple alloc]initWithHTMLData:htmlDataUTF8];</code></pre>


<p>
成绩页面修改的方式有所不同</p>

<pre><code>
NSString *utf8HtmlStr = [transStr stringByReplacingOccurrencesOfString:@"content=\"text/html; charset=gb2312\" http-equiv=\"Content-Type\">" withString:@"http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">"];</code></pre>


<p>其他页面要怎么替换具体要看页面头部具体的信息是什么，然后写在 stringByReplacingOccurrencesOfString方法第一个参数部分就可以。</p>

<p>模拟登陆部分
首先是获取Cookie，这个用 NSURLRequest就能获取到，之后要在每次请求的时候加到 NSMutableURLRequest 里。AFnetworking在每次请求的时候都会建立一个NSURLRequest对象，改这个就可以。代码如下
获取cookie</p>

<pre><code> 
 NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"
http://学校的网址/default2.aspx"]];
//  cachePolicy:NSURLRequestReloadIgnoringLocalAndRemoteCacheData
                                            //timeoutInterval:3];
[NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];
NSHTTPCookieStorage *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage];
NSArray *cookies =[cookieJar cookies];
_cookieDictionary= [NSHTTPCookie requestHeaderFieldsWithCookies:cookies];
</code></pre>


<p>
获取验证码的时候必须带上cookie,每次post或者get需要带上的是登陆成功后保存下来的cookie。</p>

<pre><code> 
- (AFHTTPRequestOperation *)POST:(NSString *)URLString
                      parameters:(NSDictionary *)parameters
                         success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success
                         failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure
{
    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:@"POST" URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:nil];
    if(self.cookieDictionary) {
        [request setHTTPShouldHandleCookies:NO];
        [request setAllHTTPHeaderFields:self.cookieDictionary];
    }
</code></pre>


<p></p>

<p>模拟登陆提交的参数有 用户名,密码，验证码还有一个viewstate，这个viewstate每次都得在登陆前获取验证码图片的时候同时获取 还是通过GET请求得到页面通过html分析工具得到对应的viwestate，具体可以看我的DEMO.然后在提交参数的时候一并提
交。</p>

<pre><code> 
NSDictionary *parameters = @{@"__VIEWSTATE":self.viewState,@"txtUserName"self.xueHao.text,@"TextBox2":self.miMa.text,@"txtSecretCode":self.yanZhengMa.text,@"RadioButtonList1":@"学生",@"Button1":@""};
</code></pre>


<p>
登陆成功之后就可以用cookie随意访问各个页面了。。不过在请求查询成绩页面的时候还要提交一个viewState,这个viewState参数是从登陆成功后的第一个页面获取，Very long。
并且在访问内部所有页面的时候都要在Request Header里加一个refer参数，这个参数跟提交cookie是一样的道理，学校的系统这个东西不提交不行，但是随便提交一个任何人的页面地址居然就可以了。这部分也是加在AFHTTPRequestOperationManager类里实现文件post 和get 方法底下。</p>

<pre><code> 
   if(self.cookieDictionary) {
        NSMutableDictionary *newDictionary=[self.cookieDictionary mutableCopy];
        [newDictionary setValue:@"http://gdjwgl.bjut.edu.cn/xs_main.aspx?xh=11111111" forKey:@"Referer"];
        [request setAllHTTPHeaderFields:newDictionary];   
    }
</code></pre>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在Cocos2d-x游戏里集成iAd广告]]></title>
    <link href="http://blog.sheliw.com/blog/2014/10/25/ru-he-zai-cocos2d-xyou-xi-li-ji-cheng-iadyan-gao/"/>
    <updated>2014-10-25T12:54:03+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/10/25/ru-he-zai-cocos2d-xyou-xi-li-ji-cheng-iadyan-gao</id>
    <content type="html"><![CDATA[<p>1) Link binary with iAd.framework<a href="https://developer.apple.com/library/ios/#recipes/xcode_help-project_editor/Articles/AddingaLibrarytoaTarget.html">https://developer.apple.com/library/ios/#recipes/xcode_help-project_editor/Articles/AddingaLibrarytoaTarget.html</a></p>

<pre><code>1. In the project navigator, select your project
2. Select your target
3.  Select the 'Build Phases' tab
4.  Open 'Link Binaries With Libraries' expander    5.  Click the '+' button
6.  Select iAd.framework
</code></pre>

<p>2) Download iAdSuite<a href="https://developer.apple.com/library/ios/#samplecode/iAdSuite/Introduction/Intro.html">https://developer.apple.com/library/ios/#samplecode/iAdSuite/Introduction/Intro.html</a> and copy files BannerViewController.h and BannerViewController.m from ContainerBanner project to your project.</p>

<p>3) Modify AppController.mm, add</p>

<pre><code>&lt;code&gt;&lt;pre&gt;#import "BannerViewController.h"&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>and replace</p>

<pre><code>@implementationAppController
</code></pre>

<p>with</p>

<pre><code>@implementationAppController
{
    BannerViewController*_bannerViewController;
}
</code></pre>

<p>and</p>

<pre><code>// Set RootViewController to window
if([[UIDevicecurrentDevice].systemVersionfloatValue]&lt; 6.0)
{
//
 warning: addSubView doesn't work on iOS6
    [window addSubview:viewController.view];
}else
{
//use this method on ios6
    [window setRootViewController:viewController];
}
</code></pre>

<p>with</p>

<pre><code>_bannerViewController=[[BannerViewController alloc]initWithContentViewController:viewController];
window.rootViewController=_bannerViewController;
</code></pre>

<p>4) Modify RootViewController.mm, add</p>

<pre><code>#import"BannerViewController.h"
</code></pre>

<p>and replace
<code><pre>
/<em>
//The designated initializer.  Override if you create the controller programmatically and want to perform customization that is not appropriate for viewDidLoad.
-(id)initWithNibName:(NSString </em>)nibNameOrNil bundle:(NSBundle <em>)nibBundleOrNil {
 if((self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil])) {
//Custom initialization
}
 return self;
}
</em>/
</code></pre>
with
<code><pre>
-(id)initWithNibName:(NSString<em>)nibNameOrNil bundle:(NSBundle</em>)nibBundleOrNil
 {
    if((self=[super initWithNibName:nibNameOrNil bundle:nibBundleOrNil])){
        [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(willBeginBannerViewActionNotification:)    name:BannerViewActionWillBegin object:nil];
        [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(didFinishBannerViewActionNotification:)name:BannerViewActionDidFinisho bject:nil];
}
    return self;
}
</code></pre></p>

<p>and add the following methods
<code><pre>
-(void)willBeginBannerViewActionNotification:(NSNotification<em>)notification{
    NSLog(@&ldquo;willBeginBannerViewActionNotification&rdquo;);
}
-(void)didFinishBannerViewActionNotification:(NSNotification</em>)notification
{
    NSLog(@&ldquo;didFinishBannerViewActionNotification&rdquo;);
}
</code></pre></p>

<p>In willBeginBannerViewActionNotification you can pause your game before the banner view triggers an advertising action. In didFinishBannerViewActionNotification you can resume your game when control is returned to it.</p>

<p>BannerViewController changes EAGLView size when banner becomes visible. If you use it like that, cocos2d-x may not detect touch location correctly. Here are the modifications to BannerViewController.m required to display ADBannerView on top of EAGLView.</p>

<p>1) Edit loadView method and put line</p>

<pre><code>[contentView addSubview:_bannerView];
</code></pre>

<p>after</p>

<pre><code>[contentView addSubview:_contentController.view];
</code></pre>

<p>loadView should look like this:
<code><pre>
-(void)loadView
{
    UIView *contentView=[[UIView alloc]initWithFrame[[UIScreen mainScreen]bounds]];
   [self addChildViewController:<em>contentController];
   [contentView addSubview:</em>contentController.view];
   [<em>contentController didMoveToParentViewController:self];
   [contentView addSubview:</em>bannerView];
   self.view=contentView;
}</code></pre>
2) Edit viewDidLayoutSubviews method and replace
<code><pre>
if(<em>bannerView.bannerLoaded)
 {
    contentFrame.size.height-=bannerFrame.size.height;
    bannerFrame.origin.y=contentFrame.size.height;
}else{
   bannerFrame.origin.y=contentFrame.size.height;
}
</code></pre>
with
<code><pre>
if(</em>bannerView.bannerLoaded)
 {
    bannerFrame.origin.y=0;
}else{
    bannerFrame.origin.y= -bannerFrame.size.height;
}
</code></pre>
P.S. Are you sure you want to use iAd? Besides low fill rate, there are some limitations. For instance, Apple’s policy is not to serve iAd advertisements to applications that are designed for children as stated at <a href="https://developer.apple.com/support/ios/iad-network.html.">https://developer.apple.com/support/ios/iad-network.html.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSOperationQueue与GCD的区别]]></title>
    <link href="http://blog.sheliw.com/blog/2014/10/11/nsoperationqueue-vs-gcd/"/>
    <updated>2014-10-11T10:49:58+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/10/11/nsoperationqueue-vs-gcd</id>
    <content type="html"><![CDATA[<p>首先，我们要明确NSOperationQueue与GCD之间的关系</p>

<p>NSOpertaionQueue用GCD构建封装的，是GCD的高级抽象。
其次，我们要区别两者的不同</p>

<p>GCD仅仅支持FIFO队列，而NSOperationQueue中的队列可以被重新设置优先级，从而实现不同操作的执行顺序调整。
GCD不支持异步操作之间的依赖关系设置。如果某个操作的依赖另一个操作的数据（生产者-消费者模型是其中之一），使用NSOperationQueue能够按照正确的顺序执行操作。GCD则没有内建的依赖关系支持。</p>

<p>NSOperationQueue支持KVO，意味着我们可以观察任务的执行状态。</p>

<p>了解以上不同，我们可以从以下角度来定义原则</p>

<ol>
<li><p>性能
GCD更接近底层，而NSOperationQueue则更高级抽象，所以GCD在追求性能的底层操作来说，是速度最快的。这取决于使用Instruments进行代码性能分析，如有必要的话</p></li>
<li><p>从异步操作之间的事务性，顺序行，依赖关系，任务并发数量，任务优先级。GCD需要自己写更多的代码来实现，而NSOperationQueue已经内建了这些支持</p></li>
<li><p>如果异步操作的过程需要更多的被交互和UI呈现出来，NSOperationQueue会是一个更好的选择。底层代码中，任务之间不太互相依赖，而需要更高的并发能力，GCD则更有优势</p></li>
</ol>


<p>最后的一句话
别忘了高德纳的教诲：“在大概97%的时间里，我们应该忘记微小的性能提升。过早优化是万恶之源。”只有Instruments显示有真正的性能提升时才有必要用低级的GCD。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block, weakSelf and strongSelf]]></title>
    <link href="http://blog.sheliw.com/blog/2014/10/04/block/"/>
    <updated>2014-10-04T15:07:23+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/10/04/block</id>
    <content type="html"><![CDATA[<p>Block is powerful in Objective-C. But there is a very stupid problem called cyclic retention pitfall, that a block locked an object so that the object will never be release.</p>

<p>For example, in the function:</p>

<pre><code>
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    [self doSomething];
    [self doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>


<p>When the block is created, the compiler will capture all objects that used inside the block and add reference count by 1. In this case, self will be locked and so the object will not be released until the block is finished. Note that cyclic retention pitfall is not only happened in self object, but in 99% case, it happens in self object.</p>

<h2>Weakify</h2>

<p>To solve the problem, we can simply create a weak reference of the self, and use the weak object instead of the original object inside block. When the weak object is used, the block will not increase the reference count, so self will not be locked. We call to weakify the self.</p>

<pre><code>
__weak __typeof__(self) weakSelf = self;
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    [weakSelf doSomething];
    [weakSelf doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>


<h2>When should use weakify</h2>

<p>The block will release all objects used inside the blocks scope after the block is finished. If the block is execution type block that will be released after execution is finished, e.g.:</p>

<ul>
<li>GCD dispatch block</li>
<li>Most UIKit block</li>
</ul>


<p>It should be safe not to use weakify technique because the block&rsquo;s lifetime is determined. However, if you are using block that will store block as variable, e.g.:</p>

<ul>
<li>Blocks in NSOperation, AFHTTPRequestOperation</li>
<li>Event handler block like something in BlocksKit</li>
</ul>


<p>Because the lifetime of the block is uncertained, it is suggested to use weakify to prevent cyclic retention pitfall.</p>

<p>Use AFHTTPRequestOperation as an example, if you simple call:</p>

<pre><code>
AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];
op.responseSerializer = [AFJSONResponseSerializer serializer];
[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
    [self doSomethingUpdateControls];
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
[op start];
</code></pre>


<p>self will be locked until the network operation finished. It may be okay in most case because it will at most cost several seconds to complete the operation.</p>

<p>But, if you are handling operations using operation queue:</p>

<pre><code>
AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];
op.responseSerializer = [AFJSONResponseSerializer serializer];
[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
    [self doSomethingUpdateControls];
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
[[NSOperationQueue mainQueue] addOperation:op];
</code></pre>


<p>There will be chance that the operation will be paused in the queue. When the operation object is not released, it will lock the block scope and so theself object. In this case, if the self object is a viewController and if you don&rsquo;t want to use weakify technique, you must make sure that you have to cancel all operations
[[NSOperationQueue mainQueue] removeAllOperations] at some point like [viewDidDisappeared:(BOOL)animated].</p>

<h2>Strongify</h2>

<p>But there is another problem, because now the self is weakified. Now self will be free and weakSelf can be nil any time. In the above case, the block may able to run doSomething but failed to run doMoreThing because weakSelf may be nullified at that time.</p>

<p>To solve this, we can strongify self before use:</p>

<pre><code>
__weak __typeof__(self) weakSelf = self;
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    __strong __typeof__(self) strongSelf = weakSelf;
    [strongSelf doSomething];
    [strongSelf doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>


<p>So self will not be released inside the block call until the life cycle of the strongSelf ends.</p>

<h2>When should use strongify</h2>

<p>However, should we use strongSelf every time inside a block?</p>

<p>Yes, it’s safe to use it every time.</p>

<p>No, sometimes you can simply use the weakSelf when:</p>

<ul>
<li>You don&rsquo;t care that self will be nullified in the middle of the block. e.g. setting control’s value. Note that although weakSelf may be released in the middle, it will be nullified and will not crash the code.</li>
<li>You are sure that the self will not be released in the middle. e.g. All block are running in main thread.</li>
</ul>


<h2>Syntax Sugar</h2>

<p>We can use a third party library libextobjc so that you can some more readable code like this:</p>

<pre><code>
@weakify(self);
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    @strongify(self);   
    [self doSomething];
    [self doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在Xcode5中完整更改iOS工程的名称]]></title>
    <link href="http://blog.sheliw.com/blog/2014/09/08/ru-he-wan-zheng-geng-gai-xcode5zhong-iosde-gong-cheng-ming-zi/"/>
    <updated>2014-09-08T18:18:49+08:00</updated>
    <id>http://blog.sheliw.com/blog/2014/09/08/ru-he-wan-zheng-geng-gai-xcode5zhong-iosde-gong-cheng-ming-zi</id>
    <content type="html"><![CDATA[<p>在用Xcode开发软件的时候难免会碰到项目更名的时候，重新更名目标名还是比较方便的，如何正确的更改「xcodeproj」的项目名还有对应的目录名字呢？</p>

<p>首先要做的是备份一下整个工程文件，防止一旦更名失败还有办法补救，不然一切都毁了。</p>

<p>更名很简单，只要选中Project，按回车，就可以重命名了，也可以在右边工具栏那里进行：</p>

<p>在输入了新的名字以后，Xcode会智能的提示你，是否要把所有项目相关的名称也给重命名了，选择「Rename」。</p>

<p>做完这一步后，原来的project文件夹，已经变成新名字了，与此对应还有一些其他文件的内容。还没有完，还有一个大文件夹还是老名字：接下去把Group的名字也已相同的方式重命名。</p>

<p>但是它不会自动也重命名整个Folder，这时，访问文件，手动将所有相关的文件夹重命名，除了.xcodeproj所在的目录名字，这个后面再改，然后Xcode会出现一大堆文件丢失，先不要理他，继续选中Group的名字，然后点击右边那个文件夹，就会出现一个「Choose a location」，选中新命名的文件夹来代表就可以了。</p>

<p>这时如果编译的话，会提示Info.plist找不到，需要选中Target，然后点击那个「Choose Info.plist File&hellip;」，选择之前被重命名的Info.plist文件即可。</p>

<p>做完这步后，按Command +shift +f全局搜索老工程名，除了所有类里面的注释以外 还有一些编译 build路径等，把这些都改为新工程名。类里边头部的注释就可改可不改了。</p>

<p>这时候编译还是无法通过，提示有文件找不到，其中还是引用了老的目录。这时就只好人工去修改文件 .xcodeproj 文件目录下的「project.pbxproj」文件了，里面还有几个字段是老工程名，全部替换成新工程名，然后这时候去更改.xcodeproj所在的目录名字，这样基本就大功告成了，如果还提示missing file等警告 可以通过移动目录，删除对应SVN文件等方式解决。</p>

<p>这样，重构项目很重要的一步：重命名项目和目录名，就这样完成了。</p>

<p>补充：xcodeproj/xcuserdata 及 xcodeproj/project.xcworkspace/ 都是用户及工作区的数据，版本控制时要ignore掉，特别是多人开发的情况下。</p>
]]></content>
  </entry>
  
</feed>
