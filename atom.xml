<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[一切从简]]></title>
  <link href="http://http://zqpmaster.gitcafe.com/atom.xml" rel="self"/>
  <link href="http://http://zqpmaster.gitcafe.com/"/>
  <updated>2014-10-04T17:28:49+08:00</updated>
  <id>http://http://zqpmaster.gitcafe.com/</id>
  <author>
    <name><![CDATA[一切从简]]></name>
    <email><![CDATA[274430533@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Block, weakSelf and strongSelf]]></title>
    <link href="http://http://zqpmaster.gitcafe.com/blog/2014/10/04/block/"/>
    <updated>2014-10-04T15:07:23+08:00</updated>
    <id>http://http://zqpmaster.gitcafe.com/blog/2014/10/04/block</id>
    <content type="html"><![CDATA[<p>Block is powerful in Objective-C. But there is a very stupid problem called cyclic retention pitfall, that a block locked an object so that the object will never be release.</p>

<p>For example, in the function:</p>

<pre><code>
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    [self doSomething];
    [self doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>


<p>When the block is created, the compiler will capture all objects that used inside the block and add reference count by 1. In this case, self will be locked and so the object will not be released until the block is finished. Note that cyclic retention pitfall is not only happened in self object, but in 99% case, it happens in self object.</p>

<p>Weakify
To solve the problem, we can simply create a weak reference of the self, and use the weak object instead of the original object inside block. When the weak object is used, the block will not increase the reference count, so self will not be locked. We call to weakify the self.</p>

<pre><code>
__weak __typeof__(self) weakSelf = self;
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    [weakSelf doSomething];
    [weakSelf doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>


<p>When should use weakify
The block will release all objects used inside the blocks scope after the block is finished. If the block is execution type block that will be released after execution is finished, e.g.:</p>

<p>GCD dispatch block
Most UIKit block
It should be safe not to use weakify technique because the block&rsquo;s lifetime is determined. However, if you are using block that will store block as variable, e.g.:</p>

<p>Blocks in NSOperation, AFHTTPRequestOperation
Event handler block like something in BlocksKit
Because the lifetime of the block is uncertained, it is suggested to use weakify to prevent cyclic retention pitfall.</p>

<p>Use AFHTTPRequestOperation as an example, if you simple call:</p>

<pre><code>
AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];
op.responseSerializer = [AFJSONResponseSerializer serializer];
[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
    [self doSomethingUpdateControls];
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
[op start];
</code></pre>


<p>self will be locked until the network operation finished. It may be okay in most case because it will at most cost several seconds to complete the operation.</p>

<p>But, if you are handling operations using operation queue:</p>

<pre><code>
AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];
op.responseSerializer = [AFJSONResponseSerializer serializer];
[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
    [self doSomethingUpdateControls];
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
[[NSOperationQueue mainQueue] addOperation:op];
</code></pre>


<p>There will be chance that the operation will be paused in the queue. When the operation object is not released, it will lock the block scope and so theself object. In this case, if the self object is a viewController and if you don&rsquo;t want to use weakify technique, you must make sure that you have to cancel all operations
[[NSOperationQueue mainQueue] removeAllOperations] at some point like [viewDidDisappeared:(BOOL)animated].</p>

<p>Strongify
But there is another problem, because now the self is weakified. Now self will be free and weakSelf can be nil any time. In the above case, the block may able to run doSomething but failed to run doMoreThing because weakSelf may be nullified at that time.</p>

<p>To solve this, we can strongify self before use:</p>

<pre><code>
__weak __typeof__(self) weakSelf = self;
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    __strong __typeof__(self) strongSelf = weakSelf;
    [strongSelf doSomething];
    [strongSelf doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>


<p>So self will not be released inside the block call until the life cycle of the strongSelf ends.</p>

<p>When should use strongify
However, should we use strongSelf every time inside a block?</p>

<p>Yes, it’s safe to use it every time.</p>

<p>No, sometimes you can simply use the weakSelf when:</p>

<p>You don&rsquo;t care that self will be nullified in the middle of the block. e.g. setting control’s value. Note that although weakSelf may be released in the middle, it will be nullified and will not crash the code.
You are sure that the self will not be released in the middle. e.g. All block are running in main thread.
Syntax Sugar
We can use a third party library libextobjc so that you can some more readable code like this:</p>

<pre><code>
@weakify(self);
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    @strongify(self);   
    [self doSomething];
    [self doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何完整更改XCODE5中iOS的工程名字]]></title>
    <link href="http://http://zqpmaster.gitcafe.com/blog/2014/09/08/ru-he-wan-zheng-geng-gai-xcode5zhong-iosde-gong-cheng-ming-zi/"/>
    <updated>2014-09-08T18:18:49+08:00</updated>
    <id>http://http://zqpmaster.gitcafe.com/blog/2014/09/08/ru-he-wan-zheng-geng-gai-xcode5zhong-iosde-gong-cheng-ming-zi</id>
    <content type="html"><![CDATA[<p>在用Xcode开发软件的时候难免会碰到项目更名的时候，重新更名目标名还是比较方便的，如何正确的更改「xcodeproj」的项目名还有对应的目录名字呢？</p>

<p>首先要做的是备份一下整个工程文件，防止一旦更名失败还有办法补救，不然一切都毁了。</p>

<p>更名很简单，只要选中Project，按回车，就可以重命名了，也可以在右边那里进行：</p>

<p>再输入了新的名字以后，Xcode会智能的提示你，是否要把所有项目相关的名称也给重命名了，选择「Rename」。</p>

<p>做完这一步后，原来的project文件夹，已经变成新名字了，与此对应还有一些其他文件的内容。还没有完，还有一个大文件夹还是老名字：接下去把Group的名字也已相同的方式重命名。</p>

<p>但是它不会自动也重命名整个Folder，这时，访问文件，手动将所有相关的文件夹重命名，除了.xcodeproj所在的目录名字，这个后面再改，然后Xcode会出现一大堆文件丢失，先不要理他，继续选中Group的名字，然后点击右边那个文件夹，就会出现一个「Choose a location」，选中新命名的文件夹来代表就可以了。</p>

<p>这时如果编译的话，会提示Info.plist找不到，需要选中Target，然后点击那个「Choose Info.plist File&hellip;」，选择之前被重命名的Info.plist文件即可。</p>

<p>做完这步后，按Command +shift +f全局搜索老工程名，除了所有类里面的注释以外 还有一些编译 build路径等，把这些都改为新工程名。类里边头部的注释就可改可不改了。</p>

<p>这时候编译还是无法通过，提示有文件找不到，其中还是引用了老的目录。这时就只好人工去修改文件 .xcodeproj 文件目录下的「project.pbxproj」文件了，里面还有几个字段是老工程名，全部替换成新工程名，然后这时候去更改.xcodeproj所在的目录名字，这样基本就大功告成了，如果还提示missing file等警告 可以通过移动目录，删除对应SVN文件等方式解决。</p>

<p>这样，重构项目很重要的一步：重命名项目和目录名，就这样完成了。</p>

<p>补充：xcodeproj/xcuserdata 及 xcodeproj/project.xcworkspace/ 都是用户及工作区的数据，版本控制时要ignore掉，特别是多人开发的情况下。</p>
]]></content>
  </entry>
  
</feed>
