
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>一切从简</title>
  <meta name="author" content="一切从简">

  
  <meta name="description" content="首先，我们要明确NSOperationQueue与GCD之间的关系 NSOpertaionQueue用GCD构建封装的，是GCD的高级抽象。
其次，我们要区别两者的不同 GCD仅仅支持FIFO队列，而NSOperationQueue中的队列可以被重新设置优先级，从而实现不同操作的执行顺序调整。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://blog.sheliw.com/posts/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="一切从简" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">一切从简</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/11/nsoperationqueue-vs-gcd/">NSOperationQueue与GCD的区别</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-10-11T10:49:58+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>10:49 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>首先，我们要明确NSOperationQueue与GCD之间的关系</p>

<p>NSOpertaionQueue用GCD构建封装的，是GCD的高级抽象。
其次，我们要区别两者的不同</p>

<p>GCD仅仅支持FIFO队列，而NSOperationQueue中的队列可以被重新设置优先级，从而实现不同操作的执行顺序调整。
GCD不支持异步操作之间的依赖关系设置。如果某个操作的依赖另一个操作的数据（生产者-消费者模型是其中之一），使用NSOperationQueue能够按照正确的顺序执行操作。GCD则没有内建的依赖关系支持。</p>

<p>NSOperationQueue支持KVO，意味着我们可以观察任务的执行状态。</p>

<p>了解以上不同，我们可以从以下角度来定义原则</p>

<ol>
<li><p>性能
GCD更接近底层，而NSOperationQueue则更高级抽象，所以GCD在追求性能的底层操作来说，是速度最快的。这取决于使用Instruments进行代码性能分析，如有必要的话</p></li>
<li><p>从异步操作之间的事务性，顺序行，依赖关系，任务并发数量，任务优先级。GCD需要自己写更多的代码来实现，而NSOperationQueue已经内建了这些支持</p></li>
<li><p>如果异步操作的过程需要更多的被交互和UI呈现出来，NSOperationQueue会是一个更好的选择。底层代码中，任务之间不太互相依赖，而需要更高的并发能力，GCD则更有优势</p></li>
</ol>


<p>最后的一句话
别忘了高德纳的教诲：“在大概97%的时间里，我们应该忘记微小的性能提升。过早优化是万恶之源。”只有Instruments显示有真正的性能提升时才有必要用低级的GCD。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/06/guo-qing-za-tan/">国庆杂谈</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-10-06T17:20:42+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>5:20 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>距离大学毕业还有九个月左右，今天闲来无事想认真写一点东西。总结一下最近的这段时间。
这几天是国庆节假期，回到家放下了所有代码和学校的那些烦恼。在家还是很快乐的，上大学后第一次在家过古尔邦节。在北京待的时间长了，回到家感觉蔬菜都是如此的新鲜，牛羊肉都是如此真实，空气也是如此清新。两三天身体都健康了不少。</p>

<p>这几天和骆同学联系的最紧密了，给国外传个1G多的文件竟然变得这么困难。不过骆同学给我推荐的ShadowSocks翻墙软件非常的好用，速度比当年的goagent还要好。这让我不止一次的觉得一位聪明而且优秀的姑娘才是最好的。哈哈</p>

<p>回想大学过去的这三年，很复杂的感觉。今年年初回学校那晚上我失眠了，因为想起在学校那种看不到未来，又不知道往哪个方向去努力的日子实在是痛苦。不过这也许是一种前兆吧。刚入校的时候就不太喜欢我的学校。专业也是我并没有仔细考量选出来的，这注定了我前两年非常痛苦的一段时光。大学第一个转折点应该是我想清楚放下我不喜欢的专业的那天。我没有转专业，只是没有再听课，因为实在是毫无兴趣。另一个转折点是有了自己的第一台Mac后踏入了iOS开发的大门，做了一段时间的IOS开发之后，我发现我的兴趣点还是在计算机上，看C++ primer跟玩游戏一样让我兴奋足以证明这一点。</p>

<p>大三下刚开学的时候我很幸运的碰到陈哥，并且作为第一名员工加入他的创业公司，然后就开始了在朝阳区六号线终点 草房附近的一个小区上班的日子。四个月的时光可能是我大学最充实的一段日子。比起之后在网易实习的那两个月，创业公司让我更觉得我们是一个团队，并且每个人都是在用心去做每一件事情。创业公司虽然给了我很大的帮助，但是我还是想去大公司看看。给网易公司投的一份简历又一次让我的生活发生一件在这之前完全没有料想到的事情。期末考试完之后我收到了炜立姐给我的一个短信，问我能不能第二天给我安排一场面试，然后暑假我就去了网易的杭州研究院实习。网易公司有一些名校情结，里面很多人都是名校出身。他们的大部分研发都是在杭州，大公司的环境确实非常不错，我也遇到了很多非常优秀的同事。我所在部门的很多人主要做视频和音频反面的研究，但我没有看到他们是否真正喜欢自己的工作。虽然我非常喜欢去研究各种高明的制度和管理技巧，但在这方面我并没有在网易看到多少东西。不过在网易实习的那一段日子还算收获颇丰。</p>

<p>一眨眼大四上已经开学一个多月了。希望能顺利度过大学的最后一年。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/04/block/">Block, weakSelf and strongSelf</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-10-04T15:07:23+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>3:07 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Block is powerful in Objective-C. But there is a very stupid problem called cyclic retention pitfall, that a block locked an object so that the object will never be release.</p>

<p>For example, in the function:</p>

<pre><code>
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    [self doSomething];
    [self doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>


<p>When the block is created, the compiler will capture all objects that used inside the block and add reference count by 1. In this case, self will be locked and so the object will not be released until the block is finished. Note that cyclic retention pitfall is not only happened in self object, but in 99% case, it happens in self object.</p>

<h2>Weakify</h2>

<p>To solve the problem, we can simply create a weak reference of the self, and use the weak object instead of the original object inside block. When the weak object is used, the block will not increase the reference count, so self will not be locked. We call to weakify the self.</p>

<pre><code>
__weak __typeof__(self) weakSelf = self;
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    [weakSelf doSomething];
    [weakSelf doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>


<h2>When should use weakify</h2>

<p>The block will release all objects used inside the blocks scope after the block is finished. If the block is execution type block that will be released after execution is finished, e.g.:</p>

<ul>
<li>GCD dispatch block</li>
<li>Most UIKit block</li>
</ul>


<p>It should be safe not to use weakify technique because the block&rsquo;s lifetime is determined. However, if you are using block that will store block as variable, e.g.:</p>

<ul>
<li>Blocks in NSOperation, AFHTTPRequestOperation</li>
<li>Event handler block like something in BlocksKit</li>
</ul>


<p>Because the lifetime of the block is uncertained, it is suggested to use weakify to prevent cyclic retention pitfall.</p>

<p>Use AFHTTPRequestOperation as an example, if you simple call:</p>

<pre><code>
AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];
op.responseSerializer = [AFJSONResponseSerializer serializer];
[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
    [self doSomethingUpdateControls];
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
[op start];
</code></pre>


<p>self will be locked until the network operation finished. It may be okay in most case because it will at most cost several seconds to complete the operation.</p>

<p>But, if you are handling operations using operation queue:</p>

<pre><code>
AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];
op.responseSerializer = [AFJSONResponseSerializer serializer];
[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
    [self doSomethingUpdateControls];
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
[[NSOperationQueue mainQueue] addOperation:op];
</code></pre>


<p>There will be chance that the operation will be paused in the queue. When the operation object is not released, it will lock the block scope and so theself object. In this case, if the self object is a viewController and if you don&rsquo;t want to use weakify technique, you must make sure that you have to cancel all operations
[[NSOperationQueue mainQueue] removeAllOperations] at some point like [viewDidDisappeared:(BOOL)animated].</p>

<h2>Strongify</h2>

<p>But there is another problem, because now the self is weakified. Now self will be free and weakSelf can be nil any time. In the above case, the block may able to run doSomething but failed to run doMoreThing because weakSelf may be nullified at that time.</p>

<p>To solve this, we can strongify self before use:</p>

<pre><code>
__weak __typeof__(self) weakSelf = self;
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    __strong __typeof__(self) strongSelf = weakSelf;
    [strongSelf doSomething];
    [strongSelf doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>


<p>So self will not be released inside the block call until the life cycle of the strongSelf ends.</p>

<h2>When should use strongify</h2>

<p>However, should we use strongSelf every time inside a block?</p>

<p>Yes, it’s safe to use it every time.</p>

<p>No, sometimes you can simply use the weakSelf when:</p>

<ul>
<li>You don&rsquo;t care that self will be nullified in the middle of the block. e.g. setting control’s value. Note that although weakSelf may be released in the middle, it will be nullified and will not crash the code.</li>
<li>You are sure that the self will not be released in the middle. e.g. All block are running in main thread.</li>
</ul>


<h2>Syntax Sugar</h2>

<p>We can use a third party library libextobjc so that you can some more readable code like this:</p>

<pre><code>
@weakify(self);
NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease];
[ op addExecutionBlock:^ {
    @strongify(self);   
    [self doSomething];
    [self doMoreThing];
} ];
[someOperationQueue addOperation:op];
</code></pre>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/10/25/ru-he-shi-yong-xibshe-zhi-shi-tu-de-geng-duo-shu-xing/">如何使用XIB设置视图的更多属性</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/25/zheng-fang-jiao-wu-guan-li-xi-tong-ioske-hu-duan/">正方教务管理系统IOS客户端</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/25/ru-he-zai-cocos2d-xyou-xi-li-ji-cheng-iadyan-gao/">如何在Cocos2d-x游戏里集成iAd广告</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/11/nsoperationqueue-vs-gcd/">NSOperationQueue与GCD的区别</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/06/guo-qing-za-tan/">国庆杂谈</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/04/block/">Block, weakSelf and strongSelf</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>About Me</h1>
  <p>iOS，OSX开发者<br />
  <br /><a href="http://weibo.com/u/1864993670">新浪微博</a>
  <br /><a href="https://github.com/zqpmaster">GitHub</a>
</p>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - 一切从简 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'zqpsea';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
